Consider the two Imperative Language implementations (the “Interpreter” and the “Stack Machine”) given in parts one and two of this lab. One of these implementations evaluates the operands to binary operators (+, -, *, /, %, and <=) from left-to-right; the other one evaluates them from right-to-left.

(a) Give an example expression, not involving a write expression, that produces different answers depending on the order of evaluation of these operands, and hence different for the two implementations. Your expression must be written in the s-expression syntax used as input to our implementations from parts one and two.

(b) State which implementation has which behavior.

(c) Based on inspection of the implementation code and the behavior of your example, what (if anything) can be deduced about the order of evaluation of operands in Scala itself?






(a) The simplest examples just use assignment, e.g.

(+ a (:= a (+ a 1)))

Since a is implicitly initialized to 0, left-to-right evaluation yields 0 + 1 = 1 whereas right-to-left evaluation yields 1 + 1 = 2.

(b) By running the example in (a), we can deduce that the Interpreter implementation evaluates operands right-to-left, whereas the Stack Machine implementation evaluates them left-to-right.

(c) Nothing can be deduced about Scala’s evaluation order! The interpreter code explicitly sequences the evaluation of sub-expressions and binds the results to variables; the ultimate Scala arithmetic operations are performed on these variables, which are already trivially “evaluated” to integers. The Stack Machine performs operations in the order specified by its instructions, which are generated by the compiler in left-to-right order; again, the ultimate Scala arithmetic operations (performed within the machine) are on values fetched from the stack, which are already evaluated to integers.
